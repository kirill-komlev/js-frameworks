export const articles = [
	{
		title: 'JavaScript Библиотеки, jQuery',
		date: '24 декабря 2023',
		author: 'Журнал «Код',
		img: 'https://wshop.fi/eng/wp-content/uploads/2021/03/featured_jquery-scaled.jpg',
		text: `
    <p><a href="https://jquery.com/">jQuery</a> — одна из старейших (первый релиз состоялся в 2006 году), это
      небольшая, быстрая и многофункциональная
      кроссплатформенная библиотека, которая предназначена для простого написания HTML-скриптов на стороне клиента.
      Благодаря API, который работает в большом количестве браузеров, jQuery сильно упрощает обработку событий, создание
      анимации и другие задачи.</p>
    <h5>Преимущества jQuery:</h5>
    <ul>
      <li>хорошая масштабируемость;</li>
      <li>универсальность;</li>
      <li>лёгкая адаптация объектной модели DOM при добавлении и удалении элементов;</li>
      <li>оптимизированный процесс отправки HTTP-запросов;</li>
      <li>возможность использовать динамический контент.</li>
    </ul>
    <h5>Недостатки jQuery:</h5>
    <ul>
      <li>низкая скорость работы;</li>
      <li>наличие более продвинутых альтернатив;</li>
      <li>устаревший API объектной модели.</li>
    </ul>
    <p>Вот такой код выведет на экран надпись «Hello, World!»:</p>
    <img
      src="https://dzen.ru/lz5XeGt8f/K9R92bJ52/2f8d1fgEwe4/30GsGQqq6APBcAeAGRKZ53na0yBs2H2whGBbdvWFZojIXRUVmjNiHOeqH9A92EvfgpUh1IOHHjHR8Yh_NEKXKBtWPp_eu2kTDuEWBY1BDHEtmEexOou54ZfhzHNygudehw_SFYmk9odl6h3X9hLDGB-PvA1dGIAuRDfd6bGSh_MURzVKRmWrTky4T9KTlh4h8VsT7yGNffeU6Rv1poHjSw1fkxfN4z2D-_1MQzSZRxsexnNAEVTKoY31kWfnHMJ42NQ-zE8rIswFOofZXR4TKLAd0SHqyH18n-ST96BH5EhNVFJbw-53gHg4A4I70U3b0gS0QxOcyinEvNWuI5ZJvt8ascxApG0AjDWOll2QXac32xQsp8Zw8dSrWHLkgWVGzJ5S3APrMwz__0NDOVtFENpF9kiSXc5oRnSep2gbTjgdFvVMQS4pBMD5i9HVlFHkN1SQ52aJ8LeU7ZmwpgpigsfclB8N5fbKM3XABbXRR9meCb8D2dMDpIaxlmRp00J6UJX_j0hkY4VKuIKXVVmVYDIX0yFpTb-8VOvRv63AogFJ3drUz6T8Cbp2QUE1XseSXEKzARSbDy5H9BUg7BBGPdWUOsoMZSEAiLVHk9rfWyY6GxlhJw91OFPhWHYiSWIIDFad2QCkcUY4P8jJvVaJG1RAO8xT1ENhgD_eI-PXQPKYnn4IA-QjzUg4yJMQV14o9xufpCfB_f_eZBi7ZAsljsxZk5GApn1MuX1IjjSQwNJfhn-K0pRHY4j0XGyvl8o239a_AIftYoKHsAYeExUSbLoQlyqiAXp50y-ZPmXJ5ECLVd4YyGO3RPgzgMe9l4LZnAI3AZJRw-gAud1gKV3EP90TfUdI7emNSjwOFlMcnO84ldPsKgA6fVRimnKlT2UAz1dbUMBlO0S7sMiOvVsI1RlC9UFf2QKkwzARoqbcB3LQ3L8DRmQtgoM2xhZS2lFtMpXSb-aJsfHT4tx3b8etQUmWE5HMKr3Jc3NJg7BWSpNbgTqAWhPO7MF5nexm1Qs5Gx7ySAokow0AdQkWVRzTIDIQVyxqBn0-FmJbOiqNakoEHZ3bCmG-CvS7wsm6G4_TEUi3SRLcASaJMZKm5J9CPxGSsgFEraTKAfKBld3WnKh21VytIoh_dhIpVn8kgKvJCd8UVsmp_QG9ssdDsFiB2xqBvI3UWc6oRf1fqeDQjnQQEjZDxyRlCwG2TRUeXtPnuxBb6qxHPfGcrF4_6oLsycOaXFACYX-D_P-AAzGZjRmSyTaCl5nGbIe3HWFo2kk8V509yYkv6keMt8cXEt0eKrpY2eGhRfDwXi0XcioH7olMFVPWiqV3Svv9SgY7l81akUL_SpoRCWSLuh8rK5gCcBNWMgEPJOYGijRFHRZUW2h-0l9l7wJ6PtRgUf3mDyFLzFfdlcXmscz7t4yA_11H2xPIPMueVMwjzvpU4SgbCjyQVfSLQm8uywSywhaQmRTlONBQ7e4Ot3gU5Ri7YIVrx8JQn1EM7PzMMjyHgvwRyt1djbKNExoPp8G3Valpl4O2mFT1x4hq6gQINEdQFV2Q6vcUlu9uDjl-0aCWMm_KL01FmBYQj-d9yjU2yQM6kEhaUkmyT1VTiS8HddekqN-Kd5vUu0xM4ujLTzrL0F5X2mg-2NJtJQhxuRJkE3mnx-4KBZDS1ozmP42x-IkKeZ8L2NvLssLT0A4lBzPZ6-dVj_AWU7uIjiwiSkc2QZZdkBHuMdRYJGnB9HaWJFJ_LEFsg8fZEphDLnMA9PcMB_rYApmcSvIKU9ALpMRwkqsiksP0kBK7DI_lKQ-N9Y9Y1FJbYHdVW-FuifRz0yVatu3KZI_BmVuXxSb9RPO9jAJxkQBZH0A6iByajOdPOpAvaBeJN17W_MuM4qEEgHwN1xLQ3eY_2RJhKEd4Pp2kXjukCqZBTJ8UnAwutYVx-MqIfNzIU5sE84jVG49oyfqWp2PbAj8Wl_qDxKEsRgF2wk"
      alt="">`,
	},
	{
		title: 'JavaScript Библиотеки, React',
		date: '23 декабря 2023',
		author: 'Журнал «Код',
		img: 'https://robertmarshall.dev/static/26124468a363485e9c10615e0c29c7f3/49f93/react-logo-banner.jpg',
		text: `
      <p><a href="https://react.dev/">React</a> — создана в 2013 году и предназначена для создания интерактивных пользовательских интерфейсов, в основном используется в мобильных и веб-приложениях. С помощью этой библиотеки можно создавать повторно используемые компоненты, которые могут автоматически обновлять и отображать данные на странице без её перезагрузки.</p>

      <h5>Преимущества React:</h5>

      <ul>
        <li>высокая производительность;</li>
        <li>лёгкая интеграция с фронтенд- и бэкенд-фреймворками;</li>
        <li>применимость на стороне клиента и сервера;</li>
        <li>кроссплатформенность;</li>
        <li>множество документации, учебных ресурсов и пособий;</li>
        <li>простота перехода со старых версий на новые;</li>
        <li>простота поддержки структуры компонентов;</li>
        <li>простой синтаксис JSX вместо JavaScript — код проще читать и поддерживать;</li>
        <li>односторонняя привязка данных — изменения в структуре дочерних не влияют на родительские;</li>
        <li>возможность повторного использования компонентов;</li>
        <li>SEO-дружелюбность — хорошая индексируемость страниц за счёт динамической отрисовки контента;</li>
        <li>постоянное развитие библиотеки.</li>
      </ul>

      <h5>Недостатки React:</h5>

      <ul>
        <li>сложность — многие считают библиотеку раздутой и предпочитают не использовать в небольших проектах;</li>
        <li>дополнительный барьер для погружения в виде синтаксиса JSX;</li>
        <li>необходимость в инструментах сборки для правильной работы и в совместимости с другими библиотеками и фреймворками;</li>
        <li>обновление документации не всегда поспевает за выходом новых версий.</li>
      </ul>

      <p>Снова надпись «Hello, World!»:</p>
      <img
      src="https://avatars.dzeninfra.ru/get-zen_doc/271828/pub_658539103c349263cde410e7_658543a0eb35721ecb510db3/scale_1200"
      alt="">
    `,
	},
	{
		title: 'JavaScript Библиотеки, D3.js',
		date: '22 декабря 2023',
		author: 'Журнал «Код',
		img: 'https://i.imgur.com/oiWd1bZ.jpg',
		text: `
    <p><a href="https://d3js.org/">D3.js</a> — библиотека для создания интерактивных и динамических элементов визуализации данных на веб-сайтах и в веб-приложениях. Позволяет управлять объектной моделью, основанной на данных, и применять собственные стили, анимацию и интерактивизацию.</p>

    <h5>Преимущества D3.js:</h5>

    <ul>
    <li>гибкость и мощность: можно визуализировать практические любые данные, от простых графиков до сложных карт, при этом можно кастомизировать буквально каждую деталь — от цвета до типа интерактивности;</li>
    <li>совместимость с большинством современных веб-браузеров и стандартов, таких как HTML, CSS и SVG;</li>
    <li>производительность — возможность обрабатывать большие и динамические наборы данных;</li>
    <li>отсутствие потребности во внешних плагинах и фреймворках;</li>
    <li>большая коллекция визуализаций;</li>
    <li>поддержка адаптивного дизайна для разных устройств и размеров экрана.</li>
    </ul>

    <h5>Недостатки D3.js:</h5>

    <ul>
    <li>сложность изучения и погружения — это низкоуровневая библиотека со строительными блоками для создания собственных решений для визуализации данных;</li>
    <li>необходимость знать JavaScript, HTML, CSS и SVG и уметь управлять данными;</li>
    <li>частая необходимость писать много кода, чтобы получить желаемый результат;</li>
    <li>отсутствие встроенных шаблонов, тем и компонентов даже для распространённых типов визуализации данных — их нужно писать с нуля или использовать сторонние плагины или библиотеки, которые могут устареть или быть несовместимы с D3.js;</li>
    <li>необходимость адаптировать решения визуализации под изменения различных веб-браузеров и платформ, чтобы сохранить единообразие внешнего вида и работы визуализаций.</li>
    </ul>

    <p>И опять «Hello, World!»:</p>

    <img
      src="https://avatars.dzeninfra.ru/get-zen_doc/271828/pub_658539103c349263cde410e7_658543bdc55a22285539020f/scale_1200"
      alt="">`,
	},
	{
		title: 'JavaScript Фронтенд-фреймворки, Angular',
		date: '21 декабря 2023',
		author: 'Журнал «Код',
		img: 'https://wallpaperbat.com/img/839889-angular-wallpaper-top-free-angular-background.jpg',
		text: `
      <p><a href="https://angularjs.org/">Angular</a> — это компонентная среда для разработки веб-приложений, набор инструментов для сборки, тестирования и отладки кода, а также набор библиотек. Создан инженерами Google в 2010 году. Благодаря Angular разработчики смогли создавать динамические интерактивные веб-сайты, а также одностраничные приложения вместо статических HTML.</p>

      <p>В 2016 году вышла улучшенная версия Angular 2 с полностью обновлённой исходной структурой, улучшенными возможностями внедрения зависимостей, службы ведения журналов и взаимодействия между компонентами.</p>

      <h5>Преимущества Angular:</h5>

      <ul>
      <li>множество документации, учебных ресурсов и пособий;</li>
      <li>возможность создавать масштабируемые приложения;</li>
      <li>двусторонняя привязка данных — при изменении модели обновляется представление и наоборот;</li>
      <li>возможность использовать компоненты повторно;</li>
      <li>возможность изолированно работать над приложением и данными;</li>
      <li>полная поддержка фреймворка NativeScript для разработки приложений под iOS и Android.</li>
      </ul>

      <h5>Недостатки Angular:</h5>

      <ul>
      <li>необходимость использовать TypeScript — сложный синтаксис для тех, кто только переходит на Angular с классического JavaScript или jQuery;</li>
      <li>размер и раздутость — около 600 Кб, что может быть слишком много для небольшого приложения;</li>
      <li>возможные сбои в работе динамических приложений из-за сложной структуры и большого размера (решается оптимизацией кода);</li>
      <li>проблемы с поисковой индексацией.</li>
      </ul>

      <p>Привычный «Hello, World!»:</p>

    <img
      src="https://avatars.dzeninfra.ru/get-zen_doc/271828/pub_658539103c349263cde410e7_65854415eec8b90f659b6e0e/scale_1200"
      alt="">`,
	},
	{
		title: 'JavaScript Фронтенд-фреймворки, Vue',
		date: '20 декабря 2023',
		author: 'Журнал «Код',
		img: 'https://c.wallhere.com/photos/fc/1d/Vue_js_programming-1589827.jpg!d',
		text: `
      <p><a href="https://ru.vuejs.org/index.html">Vue</a> — фреймворк с открытым исходным кодом, созданный в 2014 году в Google как альтернатива Angular и React и построенный по их принципам. Используется для создания интерактивных элементов пользовательского интерфейса и его оптимизации при проектировании. Хорошо адаптируется к потребностям разработчика. Vue.js можно назвать компактным и лёгким решением, которое включает лучшие функции и практики JavaScript.</p>


      <h5>Преимущества Vue:</h5>

      <ul>
      <li>быстрая и простая настройка;</li>
      <li>гибкость — фреймворк можно внедрить с минимальными усилиями;</li>
      <li>простота — для использования достаточно знаний HTML, CSS и JavaScript;</li>
      <li>компактность и небольшой размер — сжатая версия весит около 20 Кб;</li>
      <li>универсальность — можно использовать для создания и небольших, и масштабных сложных приложений;</li>
      <li>простота интеграции с серверными фреймворками.</li>
      </ul>

      <h5>Недостатки Vue:</h5>

      <ul>
      <li>слабая поддержка — фреймворк не предлагает новым пользователям такую большую коллекцию ресурсов, как Angular и React;</li>
      <li>небольшое сообщество.</li>
      </ul>

      <p>Выводим надпись «Hello, World!»:</p>

    <img
      src="https://avatars.dzeninfra.ru/get-zen_doc/271828/pub_658539103c349263cde410e7_65854433775b804b375d87af/scale_1200"
      alt="">`,
	},
	{
		title: 'JavaScript Фронтенд-фреймворки, Ember',
		date: '19 декабря 2023',
		author: 'Журнал «Код',
		img: 'https://static1.bocoup.com/assets/2015/11/02225117/ember-header.png',
		text: `
      <p><a href="https://emberjs.com/">Ember</a>— кроссплатформенный фреймворк с открытым исходным кодом для разработки масштабируемых одностраничных веб-приложений для бизнеса. Созданный в 2011 году, отличается от других фреймворков поддержкой интерфейса командной строки Ember Command Line Tool, с помощью которой проще разрабатывать и поддерживать приложения. Использует технологию FastBoost для бесперебойной отрисовки на стороне сервера. Система маршрутизации интегрирована с URL-адресом, за счёт чего, например, шаблоны отображаются легко, данные загружаются плавно и можно отслеживать текущее состояние приложения.</p>

      <h5>Преимущества Ember:</h5>

      <ul>
      <li>простой механизм работы с API;</li>
      <li>отсутствие необходимости в настройке в большинстве случаев — можно сразу начинать писать код;</li>
      <li>множество документации, учебных ресурсов и пособий;</li>
      <li>хорошая поддержка;</li>
      <li>автогенерация компонентов и контроллеров с помощью интерфейса командной строки;</li>
      <li>расширения для Chrome и Firefox — можно мониторить и редактировать приложения онлайн;</li>
      <li>двусторонняя привязка данных, как в Angular;</li>
      <li>хорошая обратная совместимость новых версий с более ранними.</li>
      </ul>

      <h5>Недостатки Ember:</h5>

      <ul>
      <li>сложность изучения и погружения в сравнении с Vue и React;</li>
      <li>сложность для масштабных приложений;</li>
      <li>большой размер и раздутость для простых приложений;</li>
      <li>нетерпимость к использованию нестандартными способами.</li>
      </ul>

      <p>Короткий «Hello, World!»:</p>

    <img
      src="https://avatars.dzeninfra.ru/get-zen_doc/271828/pub_658539103c349263cde410e7_658544702a04ce1125d3f426/scale_1200"
      alt="">`,
	},
]

export const news = [
	{
		title: '10 изменений JavaScript за 2023 год, которые вы могли упустить',
		date: '30 января 2024',
		author: 'tproger',
		img: 'https://yrokiwp.ru/wp-content/uploads/2023/03/java-modern.jpeg',
		text: `<p>Рассказали о 10 изменениях в JavaScript и веб-разработке в 2023 году, которые вы могли пропустить. Речь идёт о Next.js, React, Angular, Vue, и Node.js.</p>

    <p>Блогер Fireship рассказал о 10 изменениях в JavaScript и веб-разработке в 2023 году, которые вы могли пропустить. Речь в ролике идёт о Next.js, React, Angular, Vue, и Node.js.</p>

    <p>Вот, о чём идёт речь в видео:</p>

    <ol>
    <li>2023 год оказался бурным: обвал банка, покупка Twitter Илоном Маском, увольнения друзей автора, аресты крипто-энтузиастов, выпуск Cybertruck Tesla и замена ChatGPT на рабочих местах.</li>
    <li>В JavaScript произошли значительные изменения: почти каждый фреймворк решил обновиться в 2023 году.</li>
    <li>Новая функция ECMAScript ‘object group by’ позволяет группировать объекты по определенному признаку, например, по возрасту.</li>
    <li>Добавлены методы ‘array to sorted’, ‘to spliced’ и ‘to reversed’, которые не изменяют исходный массив, в отличие от ‘sort’ и ‘reverse’.</li>
    <li>В HTML появились новые элементы, такие как тег ‘search’ для поисковых форм и элемент ‘dialogue’ для модальных диалогов.</li>
    <li>iOS наконец разрешила веб-приложениям отправлять push-уведомления.</li>
    <li>Next.js обновился до версии 13.4 с новой функцией ‘app directory’, позволяющей получать данные непосредственно в React-компонентах.</li>
    <li>Фреймворк Nuxt.js в экосистеме Vue.js обновил свои инструменты разработчика и предложил компоненты через унифицированную экосистему JavaScript-инструментов.</li>
    <li>Svelte ввел новую функцию ‘Runes’, изменяющую подход к реактивным переменным и управлению состоянием.</li>
    <li>Angular представил новый синтаксис шаблонов, сигналы и ‘deferrable views’ для ленивой загрузки, а также обновил свой логотип.</li>
    <li>Node.js улучшил модель разрешений и добавил собственный WebSocket клиент.</li>
    <li>Bun — новая среда выполнения JavaScript, написанная на Zig, обещает улучшенный опыт разработки и высокую производительность.</li>
    <li>HTMX получил награду ‘JavaScript Framework of the Year’, предлагая подход, сокращающий использование JavaScript.</li>
    </ol>
    <h3>Обновления ECMAScript: группировка объектов</h3>

    <p>Каждый год в ECMAScript стандартизируются новые языковые возможности, после чего они реализуются в браузерах. Одна из моих любимых новых возможностей в этом году – это группировка объектов. Представьте, у вас есть массив объектов, в котором объекты имеют похожую схему. Это могут быть записи из базы данных, где каждый объект имеет поле возраста.</p>

    <p>Вы можете использовать группировку, чтобы разделить детей и взрослых, определив функцию, которая группирует всех, кто моложе 21 года, в детей, и всех, кто старше, во взрослых. В результате получается объект, организованный в группы. Это хорошая маленькая утилита, но когда я чаще всего использую – это array to sorted, вместе с to spliced и to reversed. В JavaScript уже были методы sort и reversed, но проблема в том, что они изменяют исходный массив на месте. И это сбивает с толку, потому что другие методы, такие как map и filter, этого не делают. Вместо этого они копируют массив и возвращают новый.</p>

    <p>С помощью этих методов теперь вы можете сортировать, разворачивать и вырезать массив, рассматривая исходный как неизменяемое значение, что, как правило, является более разумным способом написания вашего кода.</p>

    <h3>Новые элементы HTML</h3>

    <p>Веб-разработчики также получили несколько крутых обновлений в виде совершенно новых элементов HTML. Например, тег search – это более семантический способ определения поля поиска на веб-сайте, который может заменить более общий тег form.</p>

    <p>Это хорошо, но элемент dialogue намного мощнее, что позволяет создавать фактические модальные диалоги и управлять ими с помощью JavaScript с использованием встроенных методов, таких как showModal и close. Еще одна хорошая утилита, но это приводит нас к пункту три.</p>

    <p>iOS позволил веб-приложениям делать push-уведомления</p>

    <p>После многолетних умолчаний и умолений Apple, iOS наконец позволяет веб-приложениям отправлять уведомления push.</p>

    <p>И это огромная победа для 0,0001% пользователей веб-сайтов, которые фактически разрешают веб-сайтам отправлять им уведомления push, что, скорее всего, ваш дедушка, который случайно нажал кнопку разрешения и теперь не знает, как ее отключить. Но теперь пришло время поговорить о веселых вещах, фреймворках.</p>

    <h3>Обновился Next.js</h3>

    <p>Самый популярный фреймворк JavaScript, Next.js, совершенно отличается от прошлого года благодаря каталогу приложений, который стал стабильным в мае с версией 13.4. Самое заметное отличие в том, что теперь вы можете получать данные непосредственно внутри компонентов React благодаря серверным компонентам, которые являются компонентами React, способными работать на сервере.</p>

    <p>Отзывы о каталоге приложений были в какой-то степени противоречивыми. С одной стороны, у него много потрясающих новых функций и он может упростить ваш код, но многие жаловались, что он кажется спешным и недоделанным, как и способ, которым сейчас запускают видеоигры, где просто выпускают что-то на рынок, а затем исправляют его в течение следующих нескольких лет. Люди жаловались на необходимость использования директивы use client везде из-за нарушения существующих библиотек React.</p>

    <p>Люди жаловались на медленный dev-сервер, который работает на Rust, что странно, потому что все, что работает на Rust, должно быть быстрым. И люди сравнивали его новую функцию серверных действий с PHP. Одно из самых оскорбительных оскорблений, которое можно сделать в отношении фреймворка JavaScript, но самая большая проблема заключается в том, что запуск Next.js довольно сложно сделать правильно вне Vercel, и это привело к проектам, таким как OpenNext, которые берут на себя утомительную задачу запуска его везде. Next по-прежнему является доминирующим мета-фреймворком, но Nuxt.js и экосистема Vue также имели много крутых обновлений в 2023 году, таких как его инструменты разработчика.</p>

    <p>Эти инструменты запускаются непосредственно в браузере и значительно упрощают понимание структуры сложного приложения. Но одна вещь, которую вы, возможно, не знали о Nuxt, – многие из его компонентов доступны через унифицированную экосистему инструментов JavaScript. Например, если вам не важен Vue.js и вы просто хотите веб-сервер, вы можете использовать Nitro для создания быстрого сервера с обычным JavaScript. Забавно, что я думаю, что экосистема Vue.js изменилась меньше всего в 2023 году, и как следствие, она кажется наиболее стабильной и предсказуемой экосистемой.</p>

    <h3>Новая функция в Svelte</h3>

    <p>С другой стороны, Svelte был разрушен в 2023 году. В шокирующем заявлении несколько месяцев назад Svelte объявил о новой функции под названием Runes, которая кардинально изменит опыт разработчика в пятой версии. Вместо определения реактивных переменных с помощью let, теперь есть такая штука, как рун, которая по сути является макросом компилятора, сообщающим компилятору Svelte, что это значение является реактивным.</p>

    <p>Svelte также избавляется от синтаксиса с двоеточием и знаком доллара и хранилищ с рунами, такими как derived и effect. Первоначальная реакция на эти изменения была отчасти смешанной, некоторые пользователи считали, что эти изменения делают Svelte гораздо больше похожим на React, от которого они пытаются отойти в разработке.</p>

    <p>Но с другой стороны, многие люди любят эти изменения и видят их как необходимые для развития фреймворка в правильном направлении. Как активный пользователь Svelte, я жду выхода окончательной версии 5, прежде чем сформировать свое мнение.</p>

    <h3>Обновления Angular</h3>

    <p>Награду за наиболее измененный фреймворк в 2023 году, однако, получил Angular. У него длинный список новых функций, но наиболее заметные изменения для ненавистников Angular – это новый синтаксис шаблонов, который предоставляет более чистый способ обработки условий и циклов, заменяя вещи вроде ngf и ng4.</p>

    <p>Кроме того, Angular также принял сигналы, как и все остальные фреймворки, и внес новую функцию под названием отложенные представления, которые позволяют декларативную ленивую загрузку непосредственно в шаблоне. Но самое главное, у Angular появился совершенно новый логотип, что действительно было единственным, что помешало ему стать самым популярным фреймворком в мире в прошлом.</p>

    <h3>Улучшился Node.js</h3>

    <p>Много сумасшедших изменений на фронт-энде, но на бэк-энде Node.js тихо стал лучше. С версией Node.js 20 была выпущена новая модель разрешений, которая улучшает безопасность, контролируя, к каким функциям имеет доступ скрипт. Очень похоже на то, что сделал Deno несколько лет назад. И затем с выпуском Node.js 21 был представлен собственный клиент WebSocket, основанный на API WebSocket в браузере.</p>

    <h3>Новая среда Bun</h3>

    <p>Самым большим дисруптором на бэк-энде JavaScript в 2023 году, однако, стал Bun. Это новая среда выполнения JavaScript, написанная на Zig, которая вышла с потрясающим опытом разработчика и дикими заявлениями о производительности. И после первоначального выпуска было обнаружено немало ошибок, но она по-прежнему остается многообещающим новым способом делать бэк-энд на JavaScript в будущем.</p>

    <h3>Фреймворк HTMX</h3>

    <p>И с этим мы рассмотрели 10 различных способов, которыми JavaScript изменился в 2023 году. Но я почти забыл о самом большом из всех – HTMX, фреймворк, который показал нам, что любой может завоевать воображение экосистемы JavaScript, если вы достаточно пошутили и мемили на Twitter.</p>

    <p>Но самое главное, как я показал здесь научно, HTMX может фактически устранить тонну JavaScript по сравнению с подходом статус-кво, принятым всеми основными фреймворками. Это идеальный JavaScript-фреймворк для ненавистников JavaScript.</p>

    <p>Именно поэтому сегодня я в восторге и почетно представляю команду HTMX с наградой JavaScript Framework of the Year, которая в основном является Нобелевской премией в мире JavaScript.</p>
    `,
	},
	{
		title: '9 главных трендов в разработке фронтенда в 2024 году',
		date: '16 января 2024',
		author: 'proglib',
		img: 'https://media.proglib.io/posts/2024/01/16/e5606304448868d5f9bffffecd7adbeb.webp',
		text: `<p><p>Самые популярные языки, технологии, инструменты и архитектурные концепции.</p>

<h3>JavaScript – по-прежнему бесспорный лидер</h3>

<p>JavaScript вызывает сложные чувства у многих разработчиков, и по разным причинам: кому-то не хватает синтаксиса для явного определения типов, на кого-то наводят тоску async/await и промисы. Альтернативные языки для разработки фронтенда есть: это и вариации на тему JS – TypeScript, CoffeeScript, – и независимые решения, которые позиционируются как замена JavaScript (хотя и транспилируются в JS во время выполнения кода) – Dart, Elm, Reason, ClojureScript. Тем не менее, 11-й год подряд JavaScript занимает первое место в рейтинге популярности Stack Overflow.</p>

<p>Фреймворки и библиотеки на основе JavaScript также лидируют в рейтинге технологий веб-разработки – Node.js для бэкенда, React.js для фронта. Стоит отметить растущую популярность Next.js – фреймворка, работающего поверх React.js: с 11 места в прошлом году он поднялся на 6 место в 2023.</p>

<h3>TypeScript набирает популярность</h3>

<p>В 2023 TypeScript занял 3 место в рейтинге самых используемых языков Octoverse – ранее эту позицию стабильно занимал Java. Количество репозиториев, использующих TypeScript, за год выросло на 37%, и вот почему:</p>

<ul>
<li>В TypeScript есть статическая типизация – возможность задавать типы данных (строка, число, массив и т. д.) для переменных, функций и классов.</li>
<li>TypeScript Compiler использует проверку типов для обнаружения ошибок во время компиляции. Это помогает предотвратить ошибки, которые могут возникнуть в результате неправильного использования переменных или функций. Например, если вы пытаетесь присвоить числовое значение строковой переменной, TypeScript Compiler выдаст ошибку.</li>
<li>В TypeScript есть интерфейсы – специальные конструкции для описания структур данных. Это упрощает совместную работу над большими проектами.</li>
<li>Благодаря аннотациям типов и интерфейсам, код на TypeScript проще понимать и масштабировать, особенно в больших проектах.</li>
<li>Есть возможность постепенного добавления TypeScript в существующие JavaScript проекты – это сильно упрощает переход на новый язык.</li>
</ul>

<p>Поскольку использование TypeScript делает код более надежным, читаемым и масштабируемым по сравнению с обычным JavaScript, и он лучше подходит для крупных проектов, следует ожидать дальнейшего роста его популярности.</p>

<h3>Прогрессивные веб-приложения (PWA) стали стандартом</h3>

<p>Прогрессивные веб-приложения (Progressive Web Apps, PWA) сочетают в себе возможности обычных сайтов и мобильных приложений:</p>

<ul>
<li>Благодаря адаптивному дизайну, PWA одинаково хорошо выглядят на всех устройствах – смартфонах, планшетах, десктопе.</li>
<li>Приложения (PWA) загружаются и работают быстрее, чем обычные сайты, открытые в браузере.</li>
<li>В отличие от обычных веб-приложений у PWA есть возможность установки – пользователи могут добавлять их на главный экран смартфона, как мобильные приложения. Пользователи могут устанавливать PWA из магазина мобильных приложений, или как расширения для браузера.</li>
<li>В отличие от нативных мобильных приложений, для обновления контента PWA не нужно специально апгрейдить или переустанавливать.</li>
<li>PWA функционируют в офлайне за счет кэширования контента и работы сервис-воркеров. Например, можно полностью загрузить изображение, даже если отключился интернет.</li>
<li>PWA могут отправлять пуш-уведомления и имеют доступ к функциям устройства как нативные приложения. Эти факторы повышают интерактивность прогрессивных приложений по сравнению с обычными сайтами.</li>
</ul>

<h3>Микрофронтенды (Micro Frontends) – микросервисы на фронтенде</h3>

<p>Идея этого архитектурного подхода пришла из бэкенд-разработки, где сложные серверные приложения часто разделяют на микросервисы. При использовании микрофронтендного подхода веб-приложение (сайт) разбивается на небольшие независимые модули с собственным жизненным циклом разработки, доставки и развертывания. Каждый такой модуль отвечает за определенную бизнес-функцию или компонент интерфейса и может быть реализован на той технологии, которая больше нравится команде разработчиков. Многие крупные компании (Netflix, PayPal, American Express) уже перешли на эту архитектуру.</p>

<p>Вот основные преимущества микрофронтендов:</p>

<ul>
<li>Каждый микрофронтенд можно развертывать независимо – это позволяет быстрее обновлять компоненты и добавлять новые функции. Независимость компонентов также увеличивает надежность приложения.</li>
<li>Разные команды могут использовать различные технологии для отдельных частей приложения, и могут работать независимо друг от друга – это упрощает масштабирование и повышает скорость реализации проекта.</li>
<li>Небольшая кодовая база упрощает поддержку и тестирование кода.</li>
<li>Микрофронтенды загружаются только тогда, когда они действительно нужны – это уменьшает общее время загрузки приложения.</li>
<li>Новые разработчики могут быстро освоить микрофронтенды, так как каждый компонент имеет собственную кодовую базу и контекст.</li>
<li>Если возникают проблемы с новой версией микрофронтенда, можно легко откатиться к предыдущей версии.</li>
<li>Поскольку каждый микросервис можно написать с использованием любой технологии, появляется простор для экспериментов с новыми инструментами и подходами без риска повлиять на остальную часть приложения.</li>
</ul>`,
	},
	{
		title: 'Микрофронтенд: что это такое и зачем он нужен?',
		date: '13 июля 2023',
		author: 'proglib',
		img: 'https://media.proglib.io/posts/2023/06/30/b0cbd240cd73c116327cfeec62e61b21.webp',
		text: `<p>В этой статье сравним разные способы организации микрофронтенда, изучим их преимущества и стратегии реализации.</p>

<p>В течение последних нескольких лет фронтенд-сообщество активно обсуждает и использует термин «микрофронтенд» (далее МФ). Разные компании делятся своими подходами к организации такого архитектурного решения, но пока мало описания задач, которые МФ призваны решать в сети, критериев их применимости и ограничений в использовании.</p>

<p>Статья может быть полезна как аналитикам и командам разработчиков при проектировании архитектуры проекта и выкладке процессов, так и владельцам продукта, так как внедрение МФ может обеспечить более управляемую разработку.</p>

<h3>Микрофронтенд: что это такое и зачем он нужен?</h3>

<p>Прежде чем мы перейдем к определению МФ, давайте рассмотрим несколько проблем, с которыми можно столкнуться в проектах:</p>

<ol>
<li>У вас большой проект</li>
</ol>

<p>Размер проекта обычно субъективен и может быть определен эмпирически по объему функциональности и количеству разработчиков. Если у вас достаточно работы, чтобы озадачить 1-2 фронтендеров и при этом они не будут «толкать локти» – это маленький проект, 3-6 – средний, а больше 6-8 – уже большой.</p>

<ol start="2">
<li>У вас большая команда</li>
</ol>

<p>Опять же опытным путем это более 10 фронтендеров, остальные участники не в счет. Как правило, команду такого размера уже можно разделить на подкоманды, которые берут на поддержку конкретный функционал, и обзаводятся своими аналитиками, бэкендерами и QA.</p>

<ol start="3">
<li>У вас отличный функционал</li>
</ol>

<p>Один разработчик может поддерживать только часть кода для своей подгруппы. Доработка остального кода может обойтись дорого из-за незнания предметной области или сложности реализации сторонней логики.</p>

<p>Проблемы могут усугубляться при:</p>

<ul>
<li>желании изменить стек;</li>
<li>наличии требования компании поддерживать семейство связанных проектов.</li>
</ul>

<p>Как вы можете организовать отношения между таким количеством людей? Как можно выстроить процессы на проекте такого масштаба? Как правильно разграничить зоны ответственности? Чем больше задач вы собрали, тем больше стоит задуматься о внедрении микрофронтального подхода. Так как это естественное продолжение эволюционной тенденции развития в сторону декомпозиции кода и команды проекта.</p>

<p>Таким образом, подход МФ — это разделение монолитного фронта на отдельные кодовые базы, хранящиеся в отдельных репозиториях, к которым имеют доступ отдельные подкоманды. При этом у них могут/должны быть свои демонстрационные стенды, тесты и циклы выпуска. Соответственно, микрофронт — это съемная часть интерфейса. Разделять по страницам не обязательно, функционал может быть сквозным (например, корпоративный ui-kit).</p>

<p>Отдельно стоит выделить, что МФ — это скорее организационное решение о том, как управлять сложностью разработки в большом проекте. МФ не помогут вам ускорить фронтенд, некоторые реализации, наоборот, даже замедлят его. Но такой подход ускорит саму разработку за счет выделения зон ответственности и изолированного тестирования.</p>

<h3>Микрофронтенды vs Ленивая загрузка</h3>

<p>И наоборот, стоит упомянуть ленивую загрузку по сравнению с МФ. Они решают разные задачи, но иногда люди думают, что все дело в одном, потому что в обоих случаях мы «расщепляем» приложение.</p>

<p>Ленивая загрузка решает проблему производительности:</p>

<ul>
<li>как не заставлять пользователя загружать всю сборку фронтенда;</li>
<li>как не ждать дольше, чем нужно;</li>
<li>как быстрее запустить фронт и раньше начать с ним взаимодействовать.</li>
</ul>

<p>МФ не решают проблемы с производительностью, а иногда даже усугубляют ее. Но они помогают организовать разработку более комфортно для конкретной подкоманды, минимизируя вышеперечисленные проблемы.</p>`,
	},
	{
		title: 'Что выбрать для проекта: монолиты vs микросервисы vs бессерверная архитектура',
		date: '21 декабря 2022',
		author: 'proglib',
		img: 'https://media.proglib.io/posts/2022/12/21/841af1e748a2e879ea9a746860bd2dc4.webp',
		text: `<p>Каждая технологическая компания любого размера иногда задается вопросом, как построить свою серверную архитектуру и какой подход выбрать? Давайте поговорим о преимуществах и недостатках технологий и о том, как принять правильное решение для реализации вашего проекта.</p>

<h3>Введение</h3>

<p>Есть множество разных способов для создания как небольших, так и крупномасштабных приложений. Хоть и не существует единственного «правильного» способа, полезно знать преимущества и недостатки каждого варианта, которые позволят принять обоснованное решение о выборе подхода, лучше всего подходящего для вашего конкретного случая использования. В этой статье я собираюсь сравнить монолиты, микросервисы и бессерверную архитектуру.</p>

<h3>Монолитная архитектура</h3>

<p>Монолитное приложение — это приложение «все в одном».</p>

<p>Обычно все функции содержатся в единой кодовой базе, написанной на одном языке программирования и технологическом стеке. Например, если вы создаете интернет-магазин для продажи футболок, у вас может быть одно приложение, которое обрабатывает оформление заказа, платежи, отвечает за управление запасами и за обновление заказов.</p>

<p>Приложения Monolith легче создавать и развертывать, поскольку они состоят из меньшего количества компонентов, чем микросервисы. Однако эта простота достигается за счет более сложных взаимодействий между этими компонентами, что может затруднить их масштабирование по мере роста вашего бизнеса или адаптации к изменяющимся требованиям (например, при добавлении новых функций).</p>

<p>Монолитные приложения — это не всегда плохо. Для простых приложений они могут быть идеальными. На самом деле, на заре разработки программного обеспечения микросервисов не существовало. Наши первые компьютеры были монолитными машинами, которые могли выполнять только одну задачу одномоментно (вспомните калькуляторы). Когда мы начали использовать персональные компьютеры и, в конечном итоге, мобильные устройства, наша вычислительная мощность резко увеличилась, но у нас по-прежнему одновременно работало только одно приложение — сама ОС по-прежнему была монолитной по своей природе.</p>

<p>Монолиты могут применяться в определенных случаях, но они могут быть не идеальными для каждого приложения, которое вы создаете сегодня или завтра. Например, если в вашем приложении много данных, связанных с каждой пользовательской записью, и вы сталкиваетесь с проблемами производительности из-за слишком большого количества запросов к базе данных, которые выполняются слишком быстро (это называется «запросами в секунду»), то разбиение записей пользователей на отдельные сущности, которые можно запрашивать по отдельности, может помочь решить эти проблемы, уменьшив количество запросов, выполняемых к строкам каждой таблицы базы данных в каждый момент времени...</p>

<p>Монолиты подходят для некоторых приложений, но для более сложных систем вы можете пойти дальше и разбить их на микросервисы.</p>

<h3>К преимуществам относятся:</h3>

<ol>
<li>Простая эволюция приложений</li>
</ol>

<p>С точки зрения бизнес-логики приложение действительно не имеет ограничений (особенно если вам нужны определенные данные для новой функциональности).</p>

<ol start="2">
<li>Индивидуальная надстройка и сквозная функциональность обрабатываются только один раз</li>
</ol>

<p>Задачи сквозной функциональности должны обрабатываться только один раз. Например, настройка пула подключений к источнику данных, выбор и настройка параметров Tomcat, безопасности, ведения журнала, управление исключениями, мониторинг и т. д.</p>

<ol start="3">
<li>Простота добавления в проект новых членов команды</li>
</ol>

<p>В одном месте находится весь исходный код. Новые члены команды могут быстро ознакомиться с приложением и отладить определенный функциональный поток.</p>

<ol start="4">
<li>Низкие затраты на ранней стадии разработки приложения</li>
</ol>

<p>Создается, упаковывается и развертывается одна единица развертывания, содержащая весь исходный код. Что может быть проще? Инфраструктура или разработка, если они вам нужны.</p>

<ol start="5">
<li>Простота разработки</li>
</ol>

<p>Одним из распространенных методов создания приложений является монолитный подход. Никакой другой информации не требуется. Весь исходный код находится в одном месте, что упрощает его понимание.</p>

<ol start="6">
<li>Простота отладки</li>
</ol>

<p>Поскольку весь код находится в одном месте, отладка упрощается. Найти проблему, следуя потоку запросов, очень просто.</p>

<ol start="7">
<li>Простота тестирования</li>
</ol>

<p>Вы тестируете один сервис независимо от каких-либо зависимостей. Обычно все очевидно.</p>

<ol start="8">
<li>Простота развертывания</li>
</ol>

<p>Рекомендуется развертывать только один модуль развертывания (например, jar-файл). Нет никакой зависимости. Нет критических изменений, когда пользовательский интерфейс упакован с внутренним кодом. Все находится в одной области и меняется там.</p>

<p>После успешного запуска приложения начинают появляться проблемы с монолитной архитектурой. Рост приложения является прямой причиной. Часто монолитное приложение через некоторое время превращается в другое по следующим причинам.</p>

<h3>К недостаткам относятся:</h3>

<ol>
<li>Тесная связь между сервисами (взаимозависимости)</li>
</ol>

<p>Если вы измените что-то в одном сервисе, это может нарушить функциональность другого сервиса, потому что они были тесно связаны друг с другом без каких-либо уровней абстракции между ними (например, между ними не было интерфейсов).</p>

<ol start="2">
<li>Владение кодом неприменимо</li>
</ol>

<p>Структура расширяется. Следующим логичным шагом будет распределение обязанностей между различными командами. Например, одна команда может сосредоточиться на обслуживании рейсов, а другая — на обслуживании выставления счетов. Однако различий между этими услугами нет. Команды могут влиять друг на друга.</p>

<ol start="3">
<li>Проблемы с производительностью</li>
</ol>

<p>В случае проблем с производительностью вы можете масштабировать всю монолитную службу. Но как быть с базой данных? Все сервисы опираются на единую базу данных. Вы можете начать с оптимизации запросов к базе данных или с использования реплик чтения. Однако этот тип оптимизации ограничен.</p>

<ol start="4">
<li>Инфраструктура стоит денег</li>
</ol>

<p>В случае низкой производительности следует масштабировать весь монолитный сервис. Это увеличивает стоимость работоспособности приложения.</p>

<ol start="5">
<li>Технологии прошлого</li>
</ol>

<p>Предположим, ваше приложение написано на Node.js 11.2.0. Сколько времени займет миграция всего монолита с несколькими службами под ним на Node.js 18.0.0? Что делать с задачами, необходимыми для добавления нового функционала? Возможно, приложение никогда не будет перенесено.</p>

<ol start="6">
<li>Отсутствие адаптивности</li>
</ol>

<p>Когда вы используете монолитную архитектуру, вы ограничены технологиями, которые используются в вашем монолите. Другие инструменты использовать нельзя, даже если они лучше подходят для решения поставленной задачи.</p>

<ol start="7">
<li>Проблемы с развертыванием</li>
</ol>

<p>Даже незначительные изменения требуют повторного развертывания всего монолита.</p>

<h3>Архитектура микросервисов</h3>

<p>Микросервисы — это приложения «все-в-одном», разбитые на более мелкие части.</p>

<p>Микросервисы — это архитектурный шаблон, который упорядочивает приложение как набор слабосвязанных мелкомодульных сервисов, взаимодействующих через облегченные протоколы. Это отличается от монолита, который представляет собой приложение, написанное на одном языке и работающее вместе как одна единица кода.</p>

<p>Архитектура микросервисов — это современный подход к разработке программных приложений из набора отдельных модулей (сервисов). Каждая услуга обычно ориентирована на одну задачу (оплата, доставка и т. д.) или бизнес-функцию и может быть построена с использованием уникального набора технологий.</p>

<p>Это обеспечивает гибкость как для инженерных групп, так и для бизнеса в целом. Например, приложения на основе микросервисов легче масштабировать. Отдельные сервисы часто быстрее разрабатывать и развертывать, чем монолитные приложения. И на этом преимущества микросервисов не заканчиваются.</p>

<p>Есть много компаний, использующих микросервисы для своих продуктов и услуг, и вот список некоторых из них, которые поделились своим опытом: Comcast Cable, Uber, Netflix, Amazon, eBay, Sound Cloud, Karma, Microsoft, Groupon, Hailo, Gilt, Zalando, Lending Club, AutoScout24 и т. д.</p>

<p>Давайте углубимся в преимущества микросервисов. Вы увидите, как этот подход помогает компаниям создавать долговечные и высокопроизводительные приложения, сокращать время выхода на рынок и эффективно адаптироваться к изменениям.</p>

<h3>К преимуществам относятся:</h3>

<ol>
<li>Микросервисы легче тестировать</li>
</ol>

<p>Вы можете тестировать и изменять небольшие части системы, вы можете тестировать микросервис без необходимости тестировать всю систему. Вам не нужно «поднимать» все свои экземпляры только для того, чтобы вы могли запустить несколько тестов на одном маленьком фрагменте. Вам также не нужно беспокоиться о поломке остальной части вашего приложения при опробовании новых функций или исправлении ошибок в отдельном микросервисе. Это значительно упрощает работу разработчиков, поскольку они могут сосредоточиться на своей части проекта, не беспокоясь о том, как это повлияет на другие части или что-нибудь сломается от взаимодействия с ним.</p>

<ol start="2">
<li>Вы можете повторно использовать код и создавать библиотеки функций с помощью микросервисов</li>
</ol>

<p>Вы можете повторно использовать код между микрослужбами и создавать библиотеки функций, которые могут совместно использоваться службами. Это означает, что вы можете создать узкоспециализированные функции для одной службы, а затем использовать тот же код в других местах. Вот почему люди любят говорить о «монолитах» как о чем-то монолитном — они такие большие, что их трудно изменить, а поскольку они такие большие, их трудно разбить на более мелкие части.</p>

<ol start="3">
<li>Микросервисы помогают ускорять процессы в компании</li>
</ol>

<p>Подход на основе микросервисов позволяет сосредоточиться на одном деле. Он позволяет использовать больше людей и больше инструментов, что облегчает быстрое развитие без ущерба для качества. Микросервисы позволяют внедрять гибкие методологии разработки, быстро выполнять итерации, поскольку они модульные по своей природе. Каждый сервис имеет свою собственную кодовую базу, что позволяет легко обновлять или заменять их при необходимости.</p>

<ol start="4">
<li>Сокращение стоимости и времени на разработку</li>
</ol>

<p>Несмотря на значительные затраты, связанные с созданием гибкой команды и инфраструктуры микросервисов, данный подход широко признан как значительный источник экономии средств, особенно в долгосрочной перспективе. Мы уже упоминали несколько преимуществ, напрямую влияющих на конечный результат: более быстрый выход на рынок, более низкие затраты на обновление и масштабирование системы и так далее. Кроме того, адаптивность микросервисов влияет на структуру команды. Это позволяет использовать модель выделенной команды для создания гибких групп — как внутренних, так и удаленных — отвечающих за конкретные модули или бизнес-функции. Эти команды могут работать параллельно, повышая производительность и скорость работы.</p>

<ol start="5">
<li>Каждый модуль развертывается независимо</li>
</ol>

<p>Микросервисы можно развертывать независимо в любом приложении, поскольку они являются отдельными модулями. При изменении любого модуля нет необходимости перестраивать и развертывать все приложение. Меньшие кодовые базы обеспечивают более простое и быстрое развертывание. Это связано с тем, что в сервисах нужно управлять меньшим количеством зависимостей. Непрерывное развертывание также возможно благодаря независимому развертыванию отдельных служб. В результате программное обеспечение всегда актуально для пользователей.</p>

<h3>К недостаткам относятся:</h3>

<ol>
<li>Увеличивающаяся сложность</li>
</ol>

<p>Cервис-ориентированная архитектура, основанная на API, состоит из множества структурных частей. Следовательно, требуется больше ресурсов для поддержки системы и обеспечения ее работы. Также может потребоваться более сложная стратегия тестирования, поскольку сервисы имеют мало общего и требуют индивидуального тестирования и отладки. Несмотря на эти проблемы, многочисленные преимущества микросервисов, а также реальный опыт и доказанные конечные преимущества побуждают компании переходить на микросервисы и продолжать инвестировать в этот подход.</p>

<ol start="2">
<li>Глобальное тестирование и отладка затруднительны</li>
</ol>

<p>По сравнению с программным обеспечением на основе микросервисов тестирование монолитного приложения значительно проще. Нам осталось только запустить наше приложение, убедиться и протестировать его подключение к базовой базе данных. Каждая служба в приложении на основе микрослужб должна сначала запускаться и тестироваться отдельно. После того как все сервисы запущены, необходимо еще раз протестировать приложение в целом.</p>

<ol start="3">
<li>Не подходит для небольших приложений</li>
</ol>

<p>Архитектура микросервисов — отличный выбор для больших приложений. Однако для небольших приложений это, скорее всего, потребует больше времени и трудностей в реализации.</p>

<ol start="4">
<li>Микросервисы могут представлять угрозу безопасности</li>
</ol>

<p>Микросервисы создают значительные проблемы с безопасностью по сравнению с монолитными приложениями из-за значительного увеличения объема данных, которыми обмениваются модули. Поскольку вы используете несколько небольших контейнеров, вы подвергаете большую часть вашей системы воздействию сети, что означает, что большая часть вашего порядка уязвима для потенциальных злоумышленников.</p>

<p>Также стоит отметить, что поскольку контейнеры легко воспроизводимы, недостаток в одном модуле может быстро перерасти в более крупную проблему. Исходный код часто используется в нескольких приложениях, предоставляя хакерам легкий доступ. В результате, если не используются надлежащие инструменты и обучение, микросервисы могут быстро превратиться в угрозу безопасности.</p>

<h3>Бессерверная архитектура</h3>

<p>Ваше приложение работает на сервере, которым вы не управляете.</p>

<p>Без необходимости управлять инфраструктурой, можно создавать и запускать приложения и сервисы, используя бессерверную архитектуру. Хотя ваше приложение продолжает работать на серверах, ваш облачный провайдер (AWS, GCP, AZURE и т. д.) берет на себя все администрирование сервера. Для запуска ваших приложений, баз данных и систем хранения вам больше не нужно выделять, масштабировать и обслуживать серверы. Пользователи могут взаимодействовать с приложениями и получать доступ к их бизнес-логике через серверы, но администрирование серверов требует значительного количества времени и ресурсов. Команды должны следить за обслуживанием серверного оборудования, программным обеспечением и обновлениями безопасности, а также за созданием резервных копий. Разработчики теперь могут сосредоточиться на создании кода приложения, переложив вышеописанные обязанности на стороннего поставщика, внедрив бессерверную архитектуру.</p>

<p>Бессерверная архитектура существует уже более десяти лет. Amazon представила первую массовую платформу FaaS, AWS Lambda, в 2014 году. В настоящее время большинство разработчиков по-прежнему используют AWS Lambda для создания бессерверных приложений, но у Google и Microsoft также есть собственные FaaS-предложения, называемые Google Cloud Functions (GCF) и Azure Functions соответственно.</p>

<p>При разработке онлайн-приложений очень мало случаев использования, когда бессерверные архитектуры неприменимы. Все связано с доступностью и развитием управляемых облачных сервисов. Многие компании даже используют гибридную стратегию, когда они разрабатывают как можно больше бессерверных технологий и используют другие технологии, чтобы заполнить пробелы.</p>

<h3>Преимущества использования бессерверной архитектуры</h3>

<ol>
<li>Стоимость</li>
</ol>

<p>Вы платите только за поступающие запросы, поэтому вы не платите за серверы или виртуальные машины, которые не используются.</p>

<ol start="2">
<li>Масштабируемость</li>
</ol>

<p>В рамках ограничений параллелизма экземпляры функций автоматически добавляются или удаляются в ответ на колебания трафика.</p>

<ol start="3">
<li>Производительность</li>
</ol>

<p>Бессерверные решения позволяют инженерам отправлять свой код в релиз без необходимости управлять какими-либо серверами, что сокращает время доставки и позволяет бизнесу быстро расти.</p>

<h3>Недостатки использования бессерверной архитектуры</h3>

<ol>
<li>Отсутствие контроля</li>
</ol>

<p>Вы не можете контролировать программный стек, который использует ваш код в бессерверных настройках. Вы должны полагаться на поставщика облачных услуг для решения любых проблем, которые затрагивают один из ваших серверов из-за сбоя оборудования, отключения центра обработки данных или других проблем.</p>

<ol start="2">
<li>Безопасность</li>
</ol>

<p>Поставщик облачных служб может одновременно запускать код нескольких своих клиентов на одном сервере. Данные вашего приложения могут быть раскрыты, если общий сервер настроен неправильно.</p>

<ol start="3">
<li>Зависимость от поставщика</li>
</ol>

<p>Крупные облачные провайдеры, такие как AWS, предоставляют различные сервисы, включая API, очереди сообщений и базы данных, которые можно использовать вместе для создания бессерверных приложений. Хотя компоненты от нескольких поставщиков можно комбинировать, сервисы от одного поставщика интегрируются легче всего.</p>

<p>4.Влияние на производительность</p>

<p>Когда функции вызываются после продолжительного периода бездействия, возникают так называемые «холодные» старты (часто встречаются в бессерверных установках), которые приводят к тому, что выполнение кода приостанавливается на большее число секунд.</p>

<ol start="5">
<li>Тестирование</li>
</ol>

<p>Unit-тесты могут проводиться разработчиками для функционального кода, но интеграционные тесты, которые оценивают, как взаимодействуют внешние и внутренние компоненты, сложны в исполнении.</p>

<h3>Вывод</h3>

<p>Монолитная архитектура идеальна для небольших приложений благодаря быстрой разработке, простоте тестирования и отладки, а также низкой стоимости. Однако по мере роста системы она может стать препятствием для бизнеса и должна эволюционировать в другую форму.</p>

<p>Как видите, использование микросервисов дает множество преимуществ. Они позволяют создавать более модульные и удобные в сопровождении приложения с меньшим риском поломки при внесении изменений. Они также предоставляют вашей команде больше гибкости во взаимодействии над проектом, облегчая им продуктивную работу на всех уровнях опыта — от младших разработчиков до тех, кто работает с этими типами систем в течение многих лет.</p>

<p>Бессерверная архитектура определяет внутреннюю структуру программы, тогда как микросервисы отвечают за построение вашего приложения на макроуровне. Бессерверное приложение может соответствовать или не соответствовать концепции микросервисов (хотя это часто рекомендуется). Все или некоторые микросервисы (или же ни один) в архитектуре микросервисов могут быть созданы с использованием технологии бессерверной архитектуры.</p>

<p>Бессерверная архитектура — это потрясающий инструмент для компаний, стремящихся ускорить выход на рынок и создавать масштабируемые и легкие приложения. Но микросервисы могут быть лучшим вариантом, если ваши приложения используют множество непрерывно выполняемых длительных задач. В гибридной архитектуре разработчики могут использовать микросервисы для обработки большинства запросов, но делегировать некоторые быстрые задачи, такие как хранение базы данных — бессерверным операциям.</p>`,
	},
]
